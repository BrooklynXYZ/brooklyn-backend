"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/neverthrow";
exports.ids = ["vendor-chunks/neverthrow"];
exports.modules = {

/***/ "(ssr)/./node_modules/neverthrow/dist/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/neverthrow/dist/index.es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Err: () => (/* binding */ Err),\n/* harmony export */   Ok: () => (/* binding */ Ok),\n/* harmony export */   Result: () => (/* binding */ Result),\n/* harmony export */   ResultAsync: () => (/* binding */ ResultAsync),\n/* harmony export */   err: () => (/* binding */ err),\n/* harmony export */   errAsync: () => (/* binding */ errAsync),\n/* harmony export */   fromAsyncThrowable: () => (/* binding */ fromAsyncThrowable),\n/* harmony export */   fromPromise: () => (/* binding */ fromPromise),\n/* harmony export */   fromSafePromise: () => (/* binding */ fromSafePromise),\n/* harmony export */   fromThrowable: () => (/* binding */ fromThrowable),\n/* harmony export */   ok: () => (/* binding */ ok),\n/* harmony export */   okAsync: () => (/* binding */ okAsync),\n/* harmony export */   safeTry: () => (/* binding */ safeTry)\n/* harmony export */ });\nconst defaultErrorConfig = {\n    withStackTrace: false\n};\n// Custom error object\n// Context / discussion: https://github.com/supermacro/neverthrow/pull/215\nconst createNeverThrowError = (message, result, config = defaultErrorConfig)=>{\n    const data = result.isOk() ? {\n        type: \"Ok\",\n        value: result.value\n    } : {\n        type: \"Err\",\n        value: result.error\n    };\n    const maybeStack = config.withStackTrace ? new Error().stack : undefined;\n    return {\n        data,\n        message,\n        stack: maybeStack\n    };\n};\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncDelegator(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n        throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function() {\n        return this;\n    }, i;\n    function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n            return (p = !p) ? {\n                value: __await(o[n](v)),\n                done: n === \"return\"\n            } : f ? f(v) : v;\n        } : f;\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nclass ResultAsync {\n    constructor(res){\n        this._promise = res;\n    }\n    static fromSafePromise(promise) {\n        const newPromise = promise.then((value)=>new Ok(value));\n        return new ResultAsync(newPromise);\n    }\n    static fromPromise(promise, errorFn) {\n        const newPromise = promise.then((value)=>new Ok(value)).catch((e)=>new Err(errorFn(e)));\n        return new ResultAsync(newPromise);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static fromThrowable(fn, errorFn) {\n        return (...args)=>{\n            return new ResultAsync((()=>__awaiter(this, void 0, void 0, function*() {\n                    try {\n                        return new Ok((yield fn(...args)));\n                    } catch (error) {\n                        return new Err(errorFn ? errorFn(error) : error);\n                    }\n                }))());\n        };\n    }\n    static combine(asyncResultList) {\n        return combineResultAsyncList(asyncResultList);\n    }\n    static combineWithAllErrors(asyncResultList) {\n        return combineResultAsyncListWithAllErrors(asyncResultList);\n    }\n    map(f) {\n        return new ResultAsync(this._promise.then((res)=>__awaiter(this, void 0, void 0, function*() {\n                if (res.isErr()) {\n                    return new Err(res.error);\n                }\n                return new Ok((yield f(res.value)));\n            })));\n    }\n    mapErr(f) {\n        return new ResultAsync(this._promise.then((res)=>__awaiter(this, void 0, void 0, function*() {\n                if (res.isOk()) {\n                    return new Ok(res.value);\n                }\n                return new Err((yield f(res.error)));\n            })));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    andThen(f) {\n        return new ResultAsync(this._promise.then((res)=>{\n            if (res.isErr()) {\n                return new Err(res.error);\n            }\n            const newValue = f(res.value);\n            return newValue instanceof ResultAsync ? newValue._promise : newValue;\n        }));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    orElse(f) {\n        return new ResultAsync(this._promise.then((res)=>__awaiter(this, void 0, void 0, function*() {\n                if (res.isErr()) {\n                    return f(res.error);\n                }\n                return new Ok(res.value);\n            })));\n    }\n    match(ok, _err) {\n        return this._promise.then((res)=>res.match(ok, _err));\n    }\n    unwrapOr(t) {\n        return this._promise.then((res)=>res.unwrapOr(t));\n    }\n    /**\r\n     * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.\r\n     */ safeUnwrap() {\n        return __asyncGenerator(this, arguments, function* safeUnwrap_1() {\n            return yield __await((yield __await((yield* __asyncDelegator(__asyncValues((yield __await(this._promise.then((res)=>res.safeUnwrap())))))))));\n        });\n    }\n    // Makes ResultAsync implement PromiseLike<Result>\n    then(successCallback, failureCallback) {\n        return this._promise.then(successCallback, failureCallback);\n    }\n}\nconst okAsync = (value)=>new ResultAsync(Promise.resolve(new Ok(value)));\nconst errAsync = (err)=>new ResultAsync(Promise.resolve(new Err(err)));\nconst fromPromise = ResultAsync.fromPromise;\nconst fromSafePromise = ResultAsync.fromSafePromise;\nconst fromAsyncThrowable = ResultAsync.fromThrowable;\n/**\r\n * Short circuits on the FIRST Err value that we find\r\n */ const combineResultList = (resultList)=>{\n    let acc = ok([]);\n    for (const result of resultList){\n        if (result.isErr()) {\n            acc = err(result.error);\n            break;\n        } else {\n            acc.map((list)=>list.push(result.value));\n        }\n    }\n    return acc;\n};\n/* This is the typesafe version of Promise.all\r\n *\r\n * Takes a list of ResultAsync<T, E> and success if all inner results are Ok values\r\n * or fails if one (or more) of the inner results are Err values\r\n */ const combineResultAsyncList = (asyncResultList)=>ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);\n/**\r\n * Give a list of all the errors we find\r\n */ const combineResultListWithAllErrors = (resultList)=>{\n    let acc = ok([]);\n    for (const result of resultList){\n        if (result.isErr() && acc.isErr()) {\n            acc.error.push(result.error);\n        } else if (result.isErr() && acc.isOk()) {\n            acc = err([\n                result.error\n            ]);\n        } else if (result.isOk() && acc.isOk()) {\n            acc.value.push(result.value);\n        }\n    // do nothing when result.isOk() && acc.isErr()\n    }\n    return acc;\n};\nconst combineResultAsyncListWithAllErrors = (asyncResultList)=>ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Result;\n(function(Result) {\n    /**\r\n     * Wraps a function with a try catch, creating a new function with the same\r\n     * arguments but returning `Ok` if successful, `Err` if the function throws\r\n     *\r\n     * @param fn function to wrap with ok on success or err on failure\r\n     * @param errorFn when an error is thrown, this will wrap the error result if provided\r\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function fromThrowable(fn, errorFn) {\n        return (...args)=>{\n            try {\n                const result = fn(...args);\n                return ok(result);\n            } catch (e) {\n                return err(errorFn ? errorFn(e) : e);\n            }\n        };\n    }\n    Result.fromThrowable = fromThrowable;\n    function combine(resultList) {\n        return combineResultList(resultList);\n    }\n    Result.combine = combine;\n    function combineWithAllErrors(resultList) {\n        return combineResultListWithAllErrors(resultList);\n    }\n    Result.combineWithAllErrors = combineWithAllErrors;\n})(Result || (Result = {}));\nconst ok = (value)=>new Ok(value);\nconst err = (err)=>new Err(err);\nfunction safeTry(body) {\n    const n = body().next();\n    if (n instanceof Promise) {\n        return n.then((r)=>r.value);\n    }\n    return n.value;\n}\nclass Ok {\n    constructor(value){\n        this.value = value;\n    }\n    isOk() {\n        return true;\n    }\n    isErr() {\n        return !this.isOk();\n    }\n    map(f) {\n        return ok(f(this.value));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    mapErr(_f) {\n        return ok(this.value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    andThen(f) {\n        return f(this.value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    orElse(_f) {\n        return ok(this.value);\n    }\n    asyncAndThen(f) {\n        return f(this.value);\n    }\n    asyncMap(f) {\n        return ResultAsync.fromSafePromise(f(this.value));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    unwrapOr(_v) {\n        return this.value;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    match(ok, _err) {\n        return ok(this.value);\n    }\n    safeUnwrap() {\n        const value = this.value;\n        /* eslint-disable-next-line require-yield */ return function*() {\n            return value;\n        }();\n    }\n    _unsafeUnwrap(_) {\n        return this.value;\n    }\n    _unsafeUnwrapErr(config) {\n        throw createNeverThrowError(\"Called `_unsafeUnwrapErr` on an Ok\", this, config);\n    }\n}\nclass Err {\n    constructor(error){\n        this.error = error;\n    }\n    isOk() {\n        return false;\n    }\n    isErr() {\n        return !this.isOk();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    map(_f) {\n        return err(this.error);\n    }\n    mapErr(f) {\n        return err(f(this.error));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    andThen(_f) {\n        return err(this.error);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    orElse(f) {\n        return f(this.error);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    asyncAndThen(_f) {\n        return errAsync(this.error);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    asyncMap(_f) {\n        return errAsync(this.error);\n    }\n    unwrapOr(v) {\n        return v;\n    }\n    match(_ok, err) {\n        return err(this.error);\n    }\n    safeUnwrap() {\n        const error = this.error;\n        return function*() {\n            yield err(error);\n            throw new Error(\"Do not use this generator out of `safeTry`\");\n        }();\n    }\n    _unsafeUnwrap(config) {\n        throw createNeverThrowError(\"Called `_unsafeUnwrap` on an Err\", this, config);\n    }\n    _unsafeUnwrapErr(_) {\n        return this.error;\n    }\n}\nconst fromThrowable = Result.fromThrowable;\n//#endregion\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV2ZXJ0aHJvdy9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFNQSxxQkFBcUI7SUFDdkJDLGdCQUFnQjtBQUNwQjtBQUNBLHNCQUFzQjtBQUN0QiwwRUFBMEU7QUFDMUUsTUFBTUMsd0JBQXdCLENBQUNDLFNBQVNDLFFBQVFDLFNBQVNMLGtCQUFrQjtJQUN2RSxNQUFNTSxPQUFPRixPQUFPRyxJQUFJLEtBQ2xCO1FBQUVDLE1BQU07UUFBTUMsT0FBT0wsT0FBT0ssS0FBSztJQUFDLElBQ2xDO1FBQUVELE1BQU07UUFBT0MsT0FBT0wsT0FBT00sS0FBSztJQUFDO0lBQ3pDLE1BQU1DLGFBQWFOLE9BQU9KLGNBQWMsR0FBRyxJQUFJVyxRQUFRQyxLQUFLLEdBQUdDO0lBQy9ELE9BQU87UUFDSFI7UUFDQUg7UUFDQVUsT0FBT0Y7SUFDWDtBQUNKO0FBRUE7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBRTlFLFNBQVNJLFVBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDaEQsU0FBU0MsTUFBTVgsS0FBSztRQUFJLE9BQU9BLGlCQUFpQlMsSUFBSVQsUUFBUSxJQUFJUyxFQUFFLFNBQVVHLE9BQU87WUFBSUEsUUFBUVo7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS1MsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUksT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVmLEtBQUs7WUFBSSxJQUFJO2dCQUFFZ0IsS0FBS04sVUFBVU8sSUFBSSxDQUFDakI7WUFBUyxFQUFFLE9BQU9rQixHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU25CLEtBQUs7WUFBSSxJQUFJO2dCQUFFZ0IsS0FBS04sU0FBUyxDQUFDLFFBQVEsQ0FBQ1Y7WUFBUyxFQUFFLE9BQU9rQixHQUFHO2dCQUFFSixPQUFP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Q3BCO0lBQ0o7SUFDQXdHLGNBQWMvRyxNQUFNLEVBQUU7UUFDbEIsTUFBTUgsc0JBQXNCLG9DQUFvQyxJQUFJLEVBQUVHO0lBQzFFO0lBQ0FpSCxpQkFBaUJELENBQUMsRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQzNHLEtBQUs7SUFDckI7QUFDSjtBQUNBLE1BQU1pRSxnQkFBZ0JrQyxPQUFPbEMsYUFBYTtBQUMxQyxZQUFZO0FBRWtJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnJvb2tseW4tbWluaWFwcC8uL25vZGVfbW9kdWxlcy9uZXZlcnRocm93L2Rpc3QvaW5kZXguZXMuanM/MDhlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkZWZhdWx0RXJyb3JDb25maWcgPSB7XHJcbiAgICB3aXRoU3RhY2tUcmFjZTogZmFsc2UsXHJcbn07XHJcbi8vIEN1c3RvbSBlcnJvciBvYmplY3RcclxuLy8gQ29udGV4dCAvIGRpc2N1c3Npb246IGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBlcm1hY3JvL25ldmVydGhyb3cvcHVsbC8yMTVcclxuY29uc3QgY3JlYXRlTmV2ZXJUaHJvd0Vycm9yID0gKG1lc3NhZ2UsIHJlc3VsdCwgY29uZmlnID0gZGVmYXVsdEVycm9yQ29uZmlnKSA9PiB7XHJcbiAgICBjb25zdCBkYXRhID0gcmVzdWx0LmlzT2soKVxyXG4gICAgICAgID8geyB0eXBlOiAnT2snLCB2YWx1ZTogcmVzdWx0LnZhbHVlIH1cclxuICAgICAgICA6IHsgdHlwZTogJ0VycicsIHZhbHVlOiByZXN1bHQuZXJyb3IgfTtcclxuICAgIGNvbnN0IG1heWJlU3RhY2sgPSBjb25maWcud2l0aFN0YWNrVHJhY2UgPyBuZXcgRXJyb3IoKS5zdGFjayA6IHVuZGVmaW5lZDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgIHN0YWNrOiBtYXliZVN0YWNrLFxyXG4gICAgfTtcclxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cblxuY2xhc3MgUmVzdWx0QXN5bmMge1xyXG4gICAgY29uc3RydWN0b3IocmVzKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tU2FmZVByb21pc2UocHJvbWlzZSkge1xyXG4gICAgICAgIGNvbnN0IG5ld1Byb21pc2UgPSBwcm9taXNlLnRoZW4oKHZhbHVlKSA9PiBuZXcgT2sodmFsdWUpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdEFzeW5jKG5ld1Byb21pc2UpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21Qcm9taXNlKHByb21pc2UsIGVycm9yRm4pIHtcclxuICAgICAgICBjb25zdCBuZXdQcm9taXNlID0gcHJvbWlzZVxyXG4gICAgICAgICAgICAudGhlbigodmFsdWUpID0+IG5ldyBPayh2YWx1ZSkpXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gbmV3IEVycihlcnJvckZuKGUpKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRBc3luYyhuZXdQcm9taXNlKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBzdGF0aWMgZnJvbVRocm93YWJsZShmbiwgZXJyb3JGbikge1xyXG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdEFzeW5jKCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT2soeWllbGQgZm4oLi4uYXJncykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnIoZXJyb3JGbiA/IGVycm9yRm4oZXJyb3IpIDogZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSkoKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb21iaW5lKGFzeW5jUmVzdWx0TGlzdCkge1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lUmVzdWx0QXN5bmNMaXN0KGFzeW5jUmVzdWx0TGlzdCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY29tYmluZVdpdGhBbGxFcnJvcnMoYXN5bmNSZXN1bHRMaXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVSZXN1bHRBc3luY0xpc3RXaXRoQWxsRXJyb3JzKGFzeW5jUmVzdWx0TGlzdCk7XHJcbiAgICB9XHJcbiAgICBtYXAoZikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0QXN5bmModGhpcy5fcHJvbWlzZS50aGVuKChyZXMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKHJlcy5pc0VycigpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycihyZXMuZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2soeWllbGQgZihyZXMudmFsdWUpKTtcclxuICAgICAgICB9KSkpO1xyXG4gICAgfVxyXG4gICAgbWFwRXJyKGYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdEFzeW5jKHRoaXMuX3Byb21pc2UudGhlbigocmVzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXMuaXNPaygpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9rKHJlcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnIoeWllbGQgZihyZXMuZXJyb3IpKTtcclxuICAgICAgICB9KSkpO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcclxuICAgIGFuZFRoZW4oZikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0QXN5bmModGhpcy5fcHJvbWlzZS50aGVuKChyZXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlcy5pc0VycigpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycihyZXMuZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZihyZXMudmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3VmFsdWUgaW5zdGFuY2VvZiBSZXN1bHRBc3luYyA/IG5ld1ZhbHVlLl9wcm9taXNlIDogbmV3VmFsdWU7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcclxuICAgIG9yRWxzZShmKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRBc3luYyh0aGlzLl9wcm9taXNlLnRoZW4oKHJlcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAocmVzLmlzRXJyKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmKHJlcy5lcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBPayhyZXMudmFsdWUpO1xyXG4gICAgICAgIH0pKSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaChvaywgX2Vycikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlLnRoZW4oKHJlcykgPT4gcmVzLm1hdGNoKG9rLCBfZXJyKSk7XHJcbiAgICB9XHJcbiAgICB1bndyYXBPcih0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2UudGhlbigocmVzKSA9PiByZXMudW53cmFwT3IodCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbXVsYXRlcyBSdXN0J3MgYD9gIG9wZXJhdG9yIGluIGBzYWZlVHJ5YCdzIGJvZHkuIFNlZSBhbHNvIGBzYWZlVHJ5YC5cclxuICAgICAqL1xyXG4gICAgc2FmZVVud3JhcCgpIHtcclxuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBzYWZlVW53cmFwXzEoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2F3YWl0KHlpZWxkIF9fYXdhaXQoeWllbGQqIF9fYXN5bmNEZWxlZ2F0b3IoX19hc3luY1ZhbHVlcyh5aWVsZCBfX2F3YWl0KHRoaXMuX3Byb21pc2UudGhlbigocmVzKSA9PiByZXMuc2FmZVVud3JhcCgpKSkpKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gTWFrZXMgUmVzdWx0QXN5bmMgaW1wbGVtZW50IFByb21pc2VMaWtlPFJlc3VsdD5cclxuICAgIHRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBva0FzeW5jID0gKHZhbHVlKSA9PiBuZXcgUmVzdWx0QXN5bmMoUHJvbWlzZS5yZXNvbHZlKG5ldyBPayh2YWx1ZSkpKTtcclxuY29uc3QgZXJyQXN5bmMgPSAoZXJyKSA9PiBuZXcgUmVzdWx0QXN5bmMoUHJvbWlzZS5yZXNvbHZlKG5ldyBFcnIoZXJyKSkpO1xyXG5jb25zdCBmcm9tUHJvbWlzZSA9IFJlc3VsdEFzeW5jLmZyb21Qcm9taXNlO1xyXG5jb25zdCBmcm9tU2FmZVByb21pc2UgPSBSZXN1bHRBc3luYy5mcm9tU2FmZVByb21pc2U7XHJcbmNvbnN0IGZyb21Bc3luY1Rocm93YWJsZSA9IFJlc3VsdEFzeW5jLmZyb21UaHJvd2FibGU7XG5cbi8qKlxyXG4gKiBTaG9ydCBjaXJjdWl0cyBvbiB0aGUgRklSU1QgRXJyIHZhbHVlIHRoYXQgd2UgZmluZFxyXG4gKi9cclxuY29uc3QgY29tYmluZVJlc3VsdExpc3QgPSAocmVzdWx0TGlzdCkgPT4ge1xyXG4gICAgbGV0IGFjYyA9IG9rKFtdKTtcclxuICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdExpc3QpIHtcclxuICAgICAgICBpZiAocmVzdWx0LmlzRXJyKCkpIHtcclxuICAgICAgICAgICAgYWNjID0gZXJyKHJlc3VsdC5lcnJvcik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWNjLm1hcCgobGlzdCkgPT4gbGlzdC5wdXNoKHJlc3VsdC52YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhY2M7XHJcbn07XHJcbi8qIFRoaXMgaXMgdGhlIHR5cGVzYWZlIHZlcnNpb24gb2YgUHJvbWlzZS5hbGxcclxuICpcclxuICogVGFrZXMgYSBsaXN0IG9mIFJlc3VsdEFzeW5jPFQsIEU+IGFuZCBzdWNjZXNzIGlmIGFsbCBpbm5lciByZXN1bHRzIGFyZSBPayB2YWx1ZXNcclxuICogb3IgZmFpbHMgaWYgb25lIChvciBtb3JlKSBvZiB0aGUgaW5uZXIgcmVzdWx0cyBhcmUgRXJyIHZhbHVlc1xyXG4gKi9cclxuY29uc3QgY29tYmluZVJlc3VsdEFzeW5jTGlzdCA9IChhc3luY1Jlc3VsdExpc3QpID0+IFJlc3VsdEFzeW5jLmZyb21TYWZlUHJvbWlzZShQcm9taXNlLmFsbChhc3luY1Jlc3VsdExpc3QpKS5hbmRUaGVuKGNvbWJpbmVSZXN1bHRMaXN0KTtcclxuLyoqXHJcbiAqIEdpdmUgYSBsaXN0IG9mIGFsbCB0aGUgZXJyb3JzIHdlIGZpbmRcclxuICovXHJcbmNvbnN0IGNvbWJpbmVSZXN1bHRMaXN0V2l0aEFsbEVycm9ycyA9IChyZXN1bHRMaXN0KSA9PiB7XHJcbiAgICBsZXQgYWNjID0gb2soW10pO1xyXG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0TGlzdCkge1xyXG4gICAgICAgIGlmIChyZXN1bHQuaXNFcnIoKSAmJiBhY2MuaXNFcnIoKSkge1xyXG4gICAgICAgICAgICBhY2MuZXJyb3IucHVzaChyZXN1bHQuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXN1bHQuaXNFcnIoKSAmJiBhY2MuaXNPaygpKSB7XHJcbiAgICAgICAgICAgIGFjYyA9IGVycihbcmVzdWx0LmVycm9yXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5pc09rKCkgJiYgYWNjLmlzT2soKSkge1xyXG4gICAgICAgICAgICBhY2MudmFsdWUucHVzaChyZXN1bHQudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkbyBub3RoaW5nIHdoZW4gcmVzdWx0LmlzT2soKSAmJiBhY2MuaXNFcnIoKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjYztcclxufTtcclxuY29uc3QgY29tYmluZVJlc3VsdEFzeW5jTGlzdFdpdGhBbGxFcnJvcnMgPSAoYXN5bmNSZXN1bHRMaXN0KSA9PiBSZXN1bHRBc3luYy5mcm9tU2FmZVByb21pc2UoUHJvbWlzZS5hbGwoYXN5bmNSZXN1bHRMaXN0KSkuYW5kVGhlbihjb21iaW5lUmVzdWx0TGlzdFdpdGhBbGxFcnJvcnMpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5hbWVzcGFjZVxyXG52YXIgUmVzdWx0O1xyXG4oZnVuY3Rpb24gKFJlc3VsdCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcyBhIGZ1bmN0aW9uIHdpdGggYSB0cnkgY2F0Y2gsIGNyZWF0aW5nIGEgbmV3IGZ1bmN0aW9uIHdpdGggdGhlIHNhbWVcclxuICAgICAqIGFyZ3VtZW50cyBidXQgcmV0dXJuaW5nIGBPa2AgaWYgc3VjY2Vzc2Z1bCwgYEVycmAgaWYgdGhlIGZ1bmN0aW9uIHRocm93c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmbiBmdW5jdGlvbiB0byB3cmFwIHdpdGggb2sgb24gc3VjY2VzcyBvciBlcnIgb24gZmFpbHVyZVxyXG4gICAgICogQHBhcmFtIGVycm9yRm4gd2hlbiBhbiBlcnJvciBpcyB0aHJvd24sIHRoaXMgd2lsbCB3cmFwIHRoZSBlcnJvciByZXN1bHQgaWYgcHJvdmlkZWRcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGZ1bmN0aW9uIGZyb21UaHJvd2FibGUoZm4sIGVycm9yRm4pIHtcclxuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9rKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnIoZXJyb3JGbiA/IGVycm9yRm4oZSkgOiBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBSZXN1bHQuZnJvbVRocm93YWJsZSA9IGZyb21UaHJvd2FibGU7XHJcbiAgICBmdW5jdGlvbiBjb21iaW5lKHJlc3VsdExpc3QpIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZVJlc3VsdExpc3QocmVzdWx0TGlzdCk7XHJcbiAgICB9XHJcbiAgICBSZXN1bHQuY29tYmluZSA9IGNvbWJpbmU7XHJcbiAgICBmdW5jdGlvbiBjb21iaW5lV2l0aEFsbEVycm9ycyhyZXN1bHRMaXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVSZXN1bHRMaXN0V2l0aEFsbEVycm9ycyhyZXN1bHRMaXN0KTtcclxuICAgIH1cclxuICAgIFJlc3VsdC5jb21iaW5lV2l0aEFsbEVycm9ycyA9IGNvbWJpbmVXaXRoQWxsRXJyb3JzO1xyXG59KShSZXN1bHQgfHwgKFJlc3VsdCA9IHt9KSk7XHJcbmNvbnN0IG9rID0gKHZhbHVlKSA9PiBuZXcgT2sodmFsdWUpO1xyXG5jb25zdCBlcnIgPSAoZXJyKSA9PiBuZXcgRXJyKGVycik7XHJcbmZ1bmN0aW9uIHNhZmVUcnkoYm9keSkge1xyXG4gICAgY29uc3QgbiA9IGJvZHkoKS5uZXh0KCk7XHJcbiAgICBpZiAobiBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICByZXR1cm4gbi50aGVuKChyKSA9PiByLnZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuLnZhbHVlO1xyXG59XHJcbmNsYXNzIE9rIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaXNPaygpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlzRXJyKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc09rKCk7XHJcbiAgICB9XHJcbiAgICBtYXAoZikge1xyXG4gICAgICAgIHJldHVybiBvayhmKHRoaXMudmFsdWUpKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuICAgIG1hcEVycihfZikge1xyXG4gICAgICAgIHJldHVybiBvayh0aGlzLnZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXHJcbiAgICBhbmRUaGVuKGYpIHtcclxuICAgICAgICByZXR1cm4gZih0aGlzLnZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXHJcbiAgICBvckVsc2UoX2YpIHtcclxuICAgICAgICByZXR1cm4gb2sodGhpcy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBhc3luY0FuZFRoZW4oZikge1xyXG4gICAgICAgIHJldHVybiBmKHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmNNYXAoZikge1xyXG4gICAgICAgIHJldHVybiBSZXN1bHRBc3luYy5mcm9tU2FmZVByb21pc2UoZih0aGlzLnZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICB1bndyYXBPcihfdikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgbWF0Y2gob2ssIF9lcnIpIHtcclxuICAgICAgICByZXR1cm4gb2sodGhpcy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBzYWZlVW53cmFwKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS15aWVsZCAqL1xyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcbiAgICBfdW5zYWZlVW53cmFwKF8pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH1cclxuICAgIF91bnNhZmVVbndyYXBFcnIoY29uZmlnKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlTmV2ZXJUaHJvd0Vycm9yKCdDYWxsZWQgYF91bnNhZmVVbndyYXBFcnJgIG9uIGFuIE9rJywgdGhpcywgY29uZmlnKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBFcnIge1xyXG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICB9XHJcbiAgICBpc09rKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlzRXJyKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc09rKCk7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBtYXAoX2YpIHtcclxuICAgICAgICByZXR1cm4gZXJyKHRoaXMuZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgbWFwRXJyKGYpIHtcclxuICAgICAgICByZXR1cm4gZXJyKGYodGhpcy5lcnJvcikpO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcclxuICAgIGFuZFRoZW4oX2YpIHtcclxuICAgICAgICByZXR1cm4gZXJyKHRoaXMuZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcclxuICAgIG9yRWxzZShmKSB7XHJcbiAgICAgICAgcmV0dXJuIGYodGhpcy5lcnJvcik7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBhc3luY0FuZFRoZW4oX2YpIHtcclxuICAgICAgICByZXR1cm4gZXJyQXN5bmModGhpcy5lcnJvcik7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBhc3luY01hcChfZikge1xyXG4gICAgICAgIHJldHVybiBlcnJBc3luYyh0aGlzLmVycm9yKTtcclxuICAgIH1cclxuICAgIHVud3JhcE9yKHYpIHtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH1cclxuICAgIG1hdGNoKF9vaywgZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVycih0aGlzLmVycm9yKTtcclxuICAgIH1cclxuICAgIHNhZmVVbndyYXAoKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmVycm9yO1xyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgeWllbGQgZXJyKGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEbyBub3QgdXNlIHRoaXMgZ2VuZXJhdG9yIG91dCBvZiBgc2FmZVRyeWAnKTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG4gICAgX3Vuc2FmZVVud3JhcChjb25maWcpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVOZXZlclRocm93RXJyb3IoJ0NhbGxlZCBgX3Vuc2FmZVVud3JhcGAgb24gYW4gRXJyJywgdGhpcywgY29uZmlnKTtcclxuICAgIH1cclxuICAgIF91bnNhZmVVbndyYXBFcnIoXykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGZyb21UaHJvd2FibGUgPSBSZXN1bHQuZnJvbVRocm93YWJsZTtcclxuLy8jZW5kcmVnaW9uXG5cbmV4cG9ydCB7IEVyciwgT2ssIFJlc3VsdCwgUmVzdWx0QXN5bmMsIGVyciwgZXJyQXN5bmMsIGZyb21Bc3luY1Rocm93YWJsZSwgZnJvbVByb21pc2UsIGZyb21TYWZlUHJvbWlzZSwgZnJvbVRocm93YWJsZSwgb2ssIG9rQXN5bmMsIHNhZmVUcnkgfTtcbiJdLCJuYW1lcyI6WyJkZWZhdWx0RXJyb3JDb25maWciLCJ3aXRoU3RhY2tUcmFjZSIsImNyZWF0ZU5ldmVyVGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJyZXN1bHQiLCJjb25maWciLCJkYXRhIiwiaXNPayIsInR5cGUiLCJ2YWx1ZSIsImVycm9yIiwibWF5YmVTdGFjayIsIkVycm9yIiwic3RhY2siLCJ1bmRlZmluZWQiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX192YWx1ZXMiLCJvIiwicyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibSIsImkiLCJjYWxsIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiX19hd2FpdCIsInYiLCJfX2FzeW5jR2VuZXJhdG9yIiwiYXN5bmNJdGVyYXRvciIsImciLCJxIiwidmVyYiIsIm4iLCJhIiwiYiIsInB1c2giLCJyZXN1bWUiLCJzZXR0bGUiLCJyIiwiZnVsZmlsbCIsImYiLCJzaGlmdCIsIl9fYXN5bmNEZWxlZ2F0b3IiLCJwIiwiX19hc3luY1ZhbHVlcyIsImQiLCJSZXN1bHRBc3luYyIsImNvbnN0cnVjdG9yIiwicmVzIiwiX3Byb21pc2UiLCJmcm9tU2FmZVByb21pc2UiLCJwcm9taXNlIiwibmV3UHJvbWlzZSIsIk9rIiwiZnJvbVByb21pc2UiLCJlcnJvckZuIiwiY2F0Y2giLCJFcnIiLCJmcm9tVGhyb3dhYmxlIiwiZm4iLCJhcmdzIiwiY29tYmluZSIsImFzeW5jUmVzdWx0TGlzdCIsImNvbWJpbmVSZXN1bHRBc3luY0xpc3QiLCJjb21iaW5lV2l0aEFsbEVycm9ycyIsImNvbWJpbmVSZXN1bHRBc3luY0xpc3RXaXRoQWxsRXJyb3JzIiwibWFwIiwiaXNFcnIiLCJtYXBFcnIiLCJhbmRUaGVuIiwibmV3VmFsdWUiLCJvckVsc2UiLCJtYXRjaCIsIm9rIiwiX2VyciIsInVud3JhcE9yIiwidCIsInNhZmVVbndyYXAiLCJhcmd1bWVudHMiLCJzYWZlVW53cmFwXzEiLCJzdWNjZXNzQ2FsbGJhY2siLCJmYWlsdXJlQ2FsbGJhY2siLCJva0FzeW5jIiwiZXJyQXN5bmMiLCJlcnIiLCJmcm9tQXN5bmNUaHJvd2FibGUiLCJjb21iaW5lUmVzdWx0TGlzdCIsInJlc3VsdExpc3QiLCJhY2MiLCJsaXN0IiwiYWxsIiwiY29tYmluZVJlc3VsdExpc3RXaXRoQWxsRXJyb3JzIiwiUmVzdWx0Iiwic2FmZVRyeSIsImJvZHkiLCJfZiIsImFzeW5jQW5kVGhlbiIsImFzeW5jTWFwIiwiX3YiLCJfdW5zYWZlVW53cmFwIiwiXyIsIl91bnNhZmVVbndyYXBFcnIiLCJfb2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/neverthrow/dist/index.es.js\n");

/***/ })

};
;